name: Meeting AI

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number containing the meeting transcript'
        required: true
        type: number
      command:
        description: 'Command to run (paste/feedback/approve)'
        required: true
        type: choice
        options:
          - paste
          - feedback
          - approve

jobs:
  meeting-ai:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          persist-credentials: false

      - name: Check command
        id: check
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
          WORKFLOW_INPUT: ${{ inputs.command }}
        run: |
          if [ -n "$WORKFLOW_INPUT" ]; then
            echo "command=$WORKFLOW_INPUT" >> $GITHUB_OUTPUT
            echo "issue_number=${{ inputs.issue_number }}" >> $GITHUB_OUTPUT
            echo "triggered_by=workflow_dispatch" >> $GITHUB_OUTPUT
          elif echo "$COMMENT_BODY" | grep -q '/meeting-ai'; then
            # Extract command from comment
            cmd=$(echo "$COMMENT_BODY" | grep -oP '/meeting-ai\s+\K\w+' || echo "paste")
            echo "command=$cmd" >> $GITHUB_OUTPUT
            echo "issue_number=${{ github.event.issue.number || github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "triggered_by=comment" >> $GITHUB_OUTPUT
          else
            echo "No meeting-ai command found"
            exit 1
          fi

      - name: Load state file
        id: load_state
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          STATE_FILE=".github/meeting-ai-state.json"
          STATE_DIR=".github"

          # Create state file if it doesn't exist
          if [ ! -f "$STATE_FILE" ]; then
            echo '{"sessions":{}}' > "$STATE_FILE"
            git add "$STATE_FILE" 2>/dev/null || true
          fi

          # Load state for this issue
          SESSION_KEY="issue-$ISSUE_NUMBER"
          CURRENT_STATE=$(cat "$STATE_FILE" | jq -r ".sessions[\"$SESSION_KEY\"] // {}")
          echo "state=$CURRENT_STATE" >> $GITHUB_OUTPUT
          echo "session_key=$SESSION_KEY" >> $GITHUB_OUTPUT

      - name: Extract transcript (paste command only)
        id: transcript
        if: steps.check.outputs.command == 'paste'
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Extract transcript from comment
          # Looks for content after /meeting-ai paste or between ```
          transcript=$(echo "$COMMENT_BODY" | sed -n '/```/,/```/p' | tail -n +2 | head -n -1)

          # If no code block, take everything after the command
          if [ -z "$transcript" ]; then
            transcript=$(echo "$COMMENT_BODY" | sed 's/\/meeting-ai\s\+paste\s\+//I' | sed 's/^\s*\n//')
          fi

          # Save to temp file
          echo "$transcript" > /tmp/transcript.txt
          echo "has_transcript=true" >> $GITHUB_OUTPUT

      - name: Gather repository context
        id: context
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          echo "=== Gathering repository context for smart matching ==="

          # Get all open issues with full details
          echo "all_issues=$(gh issue list \
            --state open \
            --limit 100 \
            --json number,title,body,state,url,labels,assignees,author,milestone \
            --jq '.')" >> $GITHUB_OUTPUT

          # Get all open PRs with full details
          echo "all_prs=$(gh pr list \
            --state open \
            --limit 100 \
            --json number,title,body,state,url,headRefName,author,reviewers,baseRefName \
            --jq '.')" >> $GITHUB_OUTPUT

          # Get CODEOWNERS if exists
          echo "codeowners=$(cat $(find . -name "CODEOWNERS" -o -name ".github/CODEOWNERS" -o -name "docs/CODEOWNERS" 2>/dev/null | head -1) 2>/dev/null || echo "")" >> $GITHUB_OUTPUT

          # Get recent contributors (last 50 commits)
          echo "recent_contributors=$(git log --pretty=format:'%an <%ae>' -50 | sort -u | head -20)" >> $GITHUB_OUTPUT

          # Get all available labels
          echo "all_labels=$(gh label list \
            --limit 100 \
            --json name,color,description \
            --jq '.')" >> $GITHUB_OUTPUT

          # Get milestones
          echo "milestones=$(gh api \
            repos/$REPO/milestones \
            --state open \
            --jq '.')" >> $GITHUB_OUTPUT

          # Get repository teams (if org repo)
          echo "teams=$(gh api \
            repos/$REPO/teams \
            -H "Accept: application/vnd.github+json" \
            --jq '. // []' 2>/dev/null || echo '[]')" >> $GITHUB_OUTPUT

          # Get custom fields/properties (GitHub Projects)
          echo "=== Context gathering complete ==="

      - name: Process meeting transcript
        id: process
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        uses: anomalyco/opencode/github@latest
        env:
          ZHIPU_API_KEY: ${{ secrets.ZHIPU_API_KEY }}
        with:
          model: zai/glm-4.7
          agent: orchestrator
          prompt: |
            You are Meeting AI - an intelligent assistant that analyzes meeting transcripts and takes smart actions on GitHub issues and PRs.

            {% if steps.check.outputs.command == 'paste' %}
            ## Meeting Transcript
            {{ cat /tmp/transcript.txt }}
            {% endif %}

            {% if steps.check.outputs.command == 'feedback' %}
            ## Previous Proposed Actions
            {{ steps.load_state.outputs.state | toJSON }}

            ## User Feedback
            {{ github.event.comment.body }}

            Please revise the proposed actions based on the feedback.
            {% endif %}

            ## Repository Context for Smart Matching

            ### Open Issues
            {{ steps.context.outputs.all_issues }}

            ### Open Pull Requests
            {{ steps.context.outputs.all_prs }}

            ### CODEOWNERS File
            {{ steps.context.outputs.codeowners }}

            ### Recent Contributors
            {{ steps.context.outputs.recent_contributors }}

            ### Available Labels
            {{ steps.context.outputs.all_labels }}

            ### Available Milestones
            {{ steps.context.outputs.milestones }}

            ### Repository Teams
            {{ steps.context.outputs.teams }}

            ## Instructions

            You are tasked with intelligently extracting action items from the meeting and matching them to the right GitHub issues/PRs with the right people.

            ### Step 1: Extract Action Items
            Identify tasks discussed in the meeting that require GitHub actions. Look for:
            - Work completed (should close issues)
            - Work needing more context (should add comments)
            - New tasks discovered (should create issues)
            - Priority changes (should update labels/milestones)
            - Assignment changes (should reassign)

            ### Step 2: Smart Issue/PR Matching
            For each action item, find the BEST matching issue or PR using:
            - **Semantic similarity**: Match keywords, topics, component names
            - **Author mentions**: If someone is mentioned, check their issues
            - **Label patterns**: Bug reports, features, docs, etc.
            - **Milestone alignment**: Same sprint/release

            If NO good match exists (confidence < 70%), mark as "new" for creation.

            ### Step 3: Smart People Detection
            Identify the RIGHT people to assign using:
            - **Direct mentions** in the transcript
            - **CODEOWNERS file** for the affected files/paths
            - **Previous assignees** of similar issues
            - **Recent contributors** to relevant code areas
            - **Team membership** if team-specific work

            Extract GitHub usernames carefully. Format: @username or just "username"

            ### Step 4: Custom Fields & Properties
            Suggest appropriate:
            - **Labels**: Use existing labels from the repository (match by category)
            - **Milestones**: Assign to appropriate milestone from available options
            - **Projects**: Suggest project board placement if applicable
            - **Priority**: Add priority labels if they exist (critical/high/medium/low)

            ### Step 5: Generate JSON Output

            Create a JSON array with this exact structure:
            ```json
            {
              "actions": [
                {
                  "id": "action-1",
                  "type": "close_issue|reopen_issue|add_comment|update_labels|set_milestone|create_issue|assign_user|close_pr|update_project",
                  "target": "#123 or 'new' (issue/PR number or 'new' for creation)",
                  "target_reasoning": "Why this issue/PR matches the discussion",
                  "title": "Brief description of what will be done",
                  "reasoning": "Why this action is needed based on the meeting",
                  "confidence": "high|medium|low (how confident are you in this match)",
                  "people_reasoning": "Why these people are assigned (CODEOWNERS, mentions, etc.)",
                  "details": {
                    "comment": "Full text to add (for add_comment)",
                    "labels": ["bug", "high-priority"],
                    "labels_to_remove": ["needs-review"],
                    "milestone": "v2.0",
                    "assignees": ["username1", "username2"],
                    "reviewers": ["username1"],
                    "new_title": "Title for new issue",
                    "new_body": "Full body for new issue with context from meeting",
                    "project": "Project Board Name",
                    "status": "In Progress",
                    "priority": "high"
                  }
                }
              ]
            }
            ```

            ### Important Rules:
            1. ALWAYS use existing labels from the repository - don't invent new ones
            2. For new issues, include full context from the meeting in the body
            3. Mention people discussed in the meeting using @username
            4. If confidence is "low", explain why in the reasoning
            5. Extract GitHub usernames carefully - they must be valid GitHub usernames
            6. Use CODEOWNERS to determine file path ownership when mentioned

            CRITICAL: Your final response must contain ONLY the JSON between ```json and ``` markers.
            Do not include any explanatory text outside the JSON block.

      - name: Parse and save state
        id: save_state
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        env:
          SESSION_KEY: ${{ steps.load_state.outputs.session_key }}
          AI_OUTPUT: ${{ steps.process.outputs.output }}
        run: |
          # Extract JSON from AI output
          actions_json=$(echo "$AI_OUTPUT" | grep -oP '(?<=```json\n).*(?=\n```)' | head -1 || echo "$AI_OUTPUT" | grep -oP '\{.*\}' | head -1)

          # Validate JSON
          if ! echo "$actions_json" | jq empty 2>/dev/null; then
            echo "Failed to parse AI output as JSON"
            echo "$AI_OUTPUT"
            exit 1
          fi

          # Update state file
          STATE_FILE=".github/meeting-ai-state.json"
          temp=$(mktemp)

          # Get current timestamp
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Build new state
          cat "$STATE_FILE" | jq \
            --arg key "$SESSION_KEY" \
            --argjson actions "$actions_json" \
            --arg timestamp "$timestamp" \
            '.sessions[$key] = {actions: $actions, created_at: $timestamp, status: "pending_approval"}' > "$temp"

          mv "$temp" "$STATE_FILE"

          # Output for next step
          echo "actions_json=$actions_json" >> $GITHUB_OUTPUT

      - name: Format action table
        id: format_table
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        env:
          ACTIONS_JSON: ${{ steps.save_state.outputs.actions_json }}
        run: |
          # Generate markdown table from JSON
          cat > /tmp/table.md << 'EOF'
            <!-- meeting-ai-actions-start -->
            ## üìã Proposed Actions from Meeting

            | # | Action | Target | Confidence | People | Details | Reasoning |
            |---|--------|--------|------------|--------|---------|-----------|
          EOF

          echo "$ACTIONS_JSON" | jq -r '.actions[] | @json' | while IFS= read -r action; do
            id=$(echo "$action" | jq -r '.id')
            type=$(echo "$action" | jq -r '.type')
            target=$(echo "$action" | jq -r '.target')
            confidence=$(echo "$action" | jq -r '.confidence // "medium"')
            people=$(echo "$action" | jq -r '.details.assignees // [] | join(", ")' | head -c 20)
            reasoning=$(echo "$action" | jq -r '.reasoning // ""' | head -c 40)

            # Format details based on type
            case "$type" in
              add_comment)
                details=$(echo "$action" | jq -r '.details.comment' | head -c 25)...
                ;;
              update_labels)
                details="Labels: $(echo "$action" | jq -r '.details.labels // [] | join(", ")')"
                ;;
              set_milestone)
                details="Milestone: $(echo "$action" | jq -r '.details.milestone')"
                ;;
              create_issue)
                details="New: $(echo "$action" | jq -r '.details.new_title' | head -c 20)..."
                ;;
              assign_user)
                details="To: $(echo "$action" | jq -r '.details.assignees // [] | join(", ")')"
                ;;
              update_project)
                details="Project: $(echo "$action" | jq -r '.details.project // ""')"
                ;;
              *)
                details="-"
                ;;
            esac

            # Confidence badge
            case "$confidence" in
              high) badge="üü¢" ;;
              medium) badge="üü°" ;;
              low) badge="üî¥" ;;
              *) badge="‚ö™" ;;
            esac

            echo "| $id | $type | $target | $badge $confidence | $people | $details | $reasoning... |" >> /tmp/table.md
          done

          cat >> /tmp/table.md << 'EOF'

            ---
            ### Legend
            - üü¢ High confidence: Strong match found
            - üü° Medium confidence: Likely match
            - üî¥ Low confidence: Please verify before approving

            ### Next Steps
            - **To provide feedback:** Comment `/meeting-ai feedback <your feedback>`
            - **To approve and execute:** Comment `/meeting-ai approve`
            <!-- meeting-ai-actions-end -->
          EOF

          echo "table=$(cat /tmp/table.md)" >> $GITHUB_OUTPUT

      - name: Post actions table
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
          TABLE: ${{ steps.format_table.outputs.table }}
        run: |
          # Post the table as a comment
          gh issue comment "$ISSUE_NUMBER" --body "$TABLE"

      - name: Execute approved actions
        id: execute
        if: steps.check.outputs.command == 'approve'
        env:
          GH_TOKEN: ${{ github.token }}
          SESSION_KEY: ${{ steps.load_state.outputs.session_key }}
          ACTIONS_JSON: ${{ steps.load_state.outputs.state }}
        run: |
          # Get actions from state
          actions=$(echo "$ACTIONS_JSON" | jq -r '.actions // empty')

          if [ -z "$actions" ] || [ "$actions" = "null" ]; then
            echo "No pending actions found. Please paste a meeting transcript first."
            gh issue comment "${{ steps.check.outputs.issue_number }}" --body "‚ùå No pending actions found. Please use `/meeting-ai paste <transcript>` first."
            exit 1
          fi

          echo "Executing actions..."
          results=()

          echo "$actions" | jq -r '.[] | @json' | while IFS= read -r action; do
            id=$(echo "$action" | jq -r '.id')
            type=$(echo "$action" | jq -r '.type')
            target=$(echo "$action" | jq -r '.target')
            details=$(echo "$action" | jq -r '.details')

            case "$type" in
              close_issue)
                number=$(echo "$target" | tr -d '#')
                gh issue close "$number" --comment "‚úÖ Closed via Meeting AI after team discussion"
                results+=("‚úÖ Closed issue #$number")
                ;;
              reopen_issue)
                number=$(echo "$target" | tr -d '#')
                gh issue reopen "$number" --comment "üîÑ Reopened via Meeting AI after team discussion"
                results+=("üîÑ Reopened issue #$number")
                ;;
              add_comment)
                number=$(echo "$target" | tr -d '#')
                comment=$(echo "$details" | jq -r '.comment')
                gh issue comment "$number" --body "üìÖ **Meeting Update:**\n\n$comment\n\n---\n*Via Meeting AI*"
                results+=("üí¨ Added comment to #$number")
                ;;
              update_labels)
                number=$(echo "$target" | tr -d '#')
                labels=$(echo "$details" | jq -r '.labels // [] | join(",")')
                labels_remove=$(echo "$details" | jq -r '.labels_to_remove // [] | join(",")')
                if [ -n "$labels_remove" ]; then
                  gh issue edit "$number" --remove-labels "$labels_remove"
                  results+=("üè∑Ô∏è Removed labels from #$number: $labels_remove")
                fi
                if [ -n "$labels" ]; then
                  gh issue edit "$number" --add-labels "$labels"
                  results+=("üè∑Ô∏è Added labels to #$number: $labels")
                fi
                ;;
              set_milestone)
                number=$(echo "$target" | tr -d '#')
                milestone=$(echo "$details" | jq -r '.milestone')
                gh issue edit "$number" --milestone "$milestone"
                results+=("üìä Set milestone on #$number: $milestone")
                ;;
              create_issue)
                title=$(echo "$details" | jq -r '.new_title')
                body=$(echo "$details" | jq -r '.new_body')
                labels=$(echo "$details" | jq -r '.labels // [] | join(",")')
                assignees=$(echo "$details" | jq -r '.assignees // [] | join(",")')
                milestone=$(echo "$details" | jq -r '.milestone // ""')

                # Build create command
                create_cmd="gh issue create --title \"$title\" --body \"$body\""
                [ -n "$labels" ] && create_cmd="$create_cmd --label \"$labels\""
                [ -n "$assignees" ] && create_cmd="$create_cmd --assignee \"$assignees\""
                [ -n "$milestone" ] && create_cmd="$create_cmd --milestone \"$milestone\""

                new_url=$(eval "$create_cmd" --json url --jq .url)
                results+=("‚ú® Created issue: $new_url")
                ;;
              assign_user)
                number=$(echo "$target" | tr -d '#')
                assignees=$(echo "$details" | jq -r '.assignees | join(",")')
                gh issue edit "$number" --add-assignee "$assignees"
                results+=("üë§ Assigned #$number to: $assignees")
                ;;
              request_review)
                number=$(echo "$target" | tr -d '#')
                reviewers=$(echo "$details" | jq -r '.reviewers | join(",")')
                gh pr edit "$number" --add-reviewer "$reviewers"
                results+=("üëÄ Requested review on PR #$number from: $reviewers")
                ;;
              close_pr)
                number=$(echo "$target" | tr -d '#')
                gh pr close "$number" --comment "‚úÖ Closed via Meeting AI after team discussion"
                results+=("‚úÖ Closed PR #$number")
                ;;
              merge_pr)
                number=$(echo "$target" | tr -d '#')
                merge_method=$(echo "$details" | jq -r '.merge_method // "merge"')
                gh pr merge "$number" --"$merge_method" --subject "Merged via Meeting AI" --body "Auto-merged after team discussion"
                results+=("üîÄ Merged PR #$number")
                ;;
              update_project)
                # Note: Project updates require project ID and item ID
                # This is a placeholder for future implementation with GitHub Projects API
                results+=("üìã Project update requested: $(echo "$details" | jq -r '.project')")
                ;;
            esac
          done

          # Clear the state after execution
          STATE_FILE=".github/meeting-ai-state.json"
          temp=$(mktemp)
          cat "$STATE_FILE" | jq --arg key "$SESSION_KEY" 'del(.sessions[$key])' > "$temp"
          mv "$temp" "$STATE_FILE"

          # Post results
          result_text="## ‚úÖ Meeting AI Actions Executed\n\n"
          for r in "${results[@]}"; do
            result_text+="$r\n"
          done
          result_text+="\n---\n*All actions completed successfully*"

          gh issue comment "${{ steps.check.outputs.issue_number }}" --body "$result_text"

      - name: Commit state changes
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -f ".github/meeting-ai-state.json" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .github/meeting-ai-state.json
            git diff --staged --quiet || git commit -m "Update meeting-ai state [skip ci]"
            git push
          fi
