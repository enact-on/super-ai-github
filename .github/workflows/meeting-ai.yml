name: Meeting AI

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number containing the meeting transcript'
        required: true
        type: number
      command:
        description: 'Command to run (paste/feedback/approve)'
        required: true
        type: choice
        options:
          - paste
          - feedback
          - approve

# Prevent concurrent runs for the same issue to avoid state conflicts
concurrency:
  group: meeting-ai-${{ github.event.issue.number || github.event.pull_request.number || inputs.issue_number }}
  cancel-in-progress: false

jobs:
  meeting-ai:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check command
        id: check
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
          WORKFLOW_INPUT: ${{ inputs.command }}
        run: |
          if [ -n "$WORKFLOW_INPUT" ]; then
            echo "command=$WORKFLOW_INPUT" >> $GITHUB_OUTPUT
            echo "issue_number=${{ inputs.issue_number }}" >> $GITHUB_OUTPUT
            echo "triggered_by=workflow_dispatch" >> $GITHUB_OUTPUT
          elif echo "$COMMENT_BODY" | grep -q '/meeting-ai'; then
            # Extract command from comment (paste, feedback, or approve)
            cmd=$(echo "$COMMENT_BODY" | grep -oE '/meeting-ai\s+(paste|feedback|approve)' | awk '{print $2}' || echo "paste")
            echo "command=$cmd" >> $GITHUB_OUTPUT
            echo "issue_number=${{ github.event.issue.number || github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "triggered_by=comment" >> $GITHUB_OUTPUT
          else
            echo "No meeting-ai command found"
            exit 0
          fi

      - name: Load state file
        id: load_state
        if: steps.check.outputs.command != ''
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          STATE_FILE=".github/meeting-ai-state.json"

          # Create state file if it doesn't exist
          if [ ! -f "$STATE_FILE" ]; then
            mkdir -p .github
            echo '{"sessions":{}}' > "$STATE_FILE"
          fi

          # Load state for this issue
          SESSION_KEY="issue-$ISSUE_NUMBER"

          # Get the actions array from the session (not the whole session object)
          CURRENT_ACTIONS=$(cat "$STATE_FILE" | jq -c ".sessions[\"$SESSION_KEY\"].actions // {\"actions\":[]}")

          echo "state<<EOF" >> $GITHUB_OUTPUT
          echo "$CURRENT_ACTIONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "session_key=$SESSION_KEY" >> $GITHUB_OUTPUT

      - name: Extract transcript (paste command only)
        id: transcript
        if: steps.check.outputs.command == 'paste'
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Extract transcript from comment
          # Looks for content between ``` markers or after the command

          # Try to extract from code block first
          transcript=$(echo "$COMMENT_BODY" | sed -n '/^```/,/^```$/p' | sed '1d;$d')

          # If no code block, take everything after /meeting-ai paste
          if [ -z "$transcript" ]; then
            transcript=$(echo "$COMMENT_BODY" | sed 's/^.*\/meeting-ai[[:space:]]*paste[[:space:]]*//')
          fi

          # Save to temp file for the AI step
          echo "$transcript" > /tmp/transcript.txt
          echo "has_transcript=true" >> $GITHUB_OUTPUT

      - name: Gather repository context
        id: context
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          echo "=== Gathering repository context ==="

          # Get all open issues (store in file to handle large output)
          gh issue list --state open --limit 50 --json number,title,labels,assignees,milestone > /tmp/issues.json

          # Get all open PRs
          gh pr list --state open --limit 50 --json number,title,author,headRefName > /tmp/prs.json

          # Get CODEOWNERS if exists
          for path in "CODEOWNERS" ".github/CODEOWNERS" "docs/CODEOWNERS"; do
            if [ -f "$path" ]; then
              cat "$path" > /tmp/codeowners.txt
              break
            fi
          done
          [ ! -f /tmp/codeowners.txt ] && echo "" > /tmp/codeowners.txt

          # Get recent contributors
          git log --pretty=format:'%an' -50 2>/dev/null | sort -u | head -20 > /tmp/contributors.txt

          # Get all available labels
          gh label list --limit 100 --json name > /tmp/labels.json

          # Get milestones
          gh api "repos/$REPO/milestones?state=open" > /tmp/milestones.json 2>/dev/null || echo '[]' > /tmp/milestones.json

          echo "context_ready=true" >> $GITHUB_OUTPUT

      - name: Process meeting transcript
        id: process
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        uses: anomalyco/opencode/github@latest
        env:
          ZHIPU_API_KEY: ${{ secrets.ZHIPU_API_KEY }}
        with:
          model: zai/glm-4.7
          agent: orchestrator
          prompt: |
            You are Meeting AI - an intelligent assistant that analyzes meeting transcripts and proposes GitHub actions.

            ## Command: ${{ steps.check.outputs.command }}

            ## Meeting Transcript
            $(cat /tmp/transcript.txt 2>/dev/null || echo "No transcript available")

            ## Previous State (for feedback command)
            ${{ steps.load_state.outputs.state }}

            ## User Feedback (for feedback command)
            ${{ github.event.comment.body }}

            ## Repository Context

            ### Open Issues
            $(cat /tmp/issues.json 2>/dev/null || echo "[]")

            ### Open Pull Requests
            $(cat /tmp/prs.json 2>/dev/null || echo "[]")

            ### CODEOWNERS
            $(cat /tmp/codeowners.txt 2>/dev/null || echo "")

            ### Recent Contributors
            $(cat /tmp/contributors.txt 2>/dev/null || echo "")

            ### Available Labels
            $(cat /tmp/labels.json 2>/dev/null || echo "[]")

            ### Milestones
            $(cat /tmp/milestones.json 2>/dev/null || echo "[]")

            ## Instructions

            Extract action items from the meeting and match them to GitHub issues/PRs.

            ### Action Types
            - close_issue: Close completed issues
            - reopen_issue: Reopen issues needing more work
            - add_comment: Add meeting context to issues
            - update_labels: Change issue labels
            - set_milestone: Update milestones
            - create_issue: Create new issues from discussion
            - assign_user: Assign/reassign issues
            - request_review: Request PR reviews
            - merge_pr: Merge approved PRs
            - close_pr: Close PRs

            ### Output Format

            Return ONLY valid JSON (no markdown, no explanation):

            {"actions":[{"id":"action-1","type":"close_issue","target":"#123","title":"Close bug fix issue","reasoning":"Bug was fixed per discussion","confidence":"high","details":{"comment":"Closing as discussed","labels":[],"assignees":[]}}]}

            Rules:
            1. Use ONLY existing labels from the repository
            2. confidence must be: high, medium, or low
            3. target is issue/PR number like "#123" or "new" for create_issue
            4. Return raw JSON only, no code blocks

      - name: Parse and save state
        id: save_state
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        env:
          SESSION_KEY: ${{ steps.load_state.outputs.session_key }}
          AI_OUTPUT: ${{ steps.process.outputs.output }}
        run: |
          STATE_FILE=".github/meeting-ai-state.json"

          # Try to extract JSON from AI output
          # First try to find JSON object directly
          actions_json=$(echo "$AI_OUTPUT" | grep -o '{.*}' | head -1)

          # If that fails, try to extract from code blocks
          if [ -z "$actions_json" ] || ! echo "$actions_json" | jq empty 2>/dev/null; then
            # Extract content between ```json and ```
            actions_json=$(echo "$AI_OUTPUT" | sed -n '/```json/,/```/p' | sed '1d;$d' | tr -d '\n')
          fi

          # Final fallback - try the whole output
          if [ -z "$actions_json" ] || ! echo "$actions_json" | jq empty 2>/dev/null; then
            actions_json="$AI_OUTPUT"
          fi

          # Validate JSON
          if ! echo "$actions_json" | jq empty 2>/dev/null; then
            echo "::error::Failed to parse AI output as JSON"
            echo "Raw output: $AI_OUTPUT"
            # Create empty actions as fallback
            actions_json='{"actions":[]}'
          fi

          # Ensure actions_json has the right structure
          if ! echo "$actions_json" | jq -e '.actions' >/dev/null 2>&1; then
            actions_json='{"actions":[]}'
          fi

          # Update state file
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          jq --arg key "$SESSION_KEY" \
             --argjson actions "$actions_json" \
             --arg timestamp "$timestamp" \
             '.sessions[$key] = {actions: $actions, created_at: $timestamp, status: "pending_approval"}' \
             "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"

          # Save actions for next step
          echo "actions_json<<EOF" >> $GITHUB_OUTPUT
          echo "$actions_json" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Format and post action table
        if: steps.check.outputs.command == 'paste' || steps.check.outputs.command == 'feedback'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
          ACTIONS_JSON: ${{ steps.save_state.outputs.actions_json }}
        run: |
          # Build markdown table
          TABLE="## üìã Proposed Actions from Meeting\n\n"
          TABLE+="| # | Action | Target | Confidence | Details |\n"
          TABLE+="|---|--------|--------|------------|--------|\n"

          # Parse actions and build table rows
          echo "$ACTIONS_JSON" | jq -r '.actions[] | "\(.id)|\(.type)|\(.target)|\(.confidence)|\(.title // .reasoning | .[0:50])"' | while IFS='|' read -r id type target confidence details; do
            # Confidence badge
            case "$confidence" in
              high) badge="üü¢" ;;
              medium) badge="üü°" ;;
              low) badge="üî¥" ;;
              *) badge="‚ö™" ;;
            esac
            TABLE+="| $id | $type | $target | $badge $confidence | $details |\n"
          done

          TABLE+="\n---\n"
          TABLE+="### Legend\n"
          TABLE+="- üü¢ High confidence | üü° Medium confidence | üî¥ Low confidence\n\n"
          TABLE+="### Next Steps\n"
          TABLE+="- **Feedback:** \`/meeting-ai feedback <your feedback>\`\n"
          TABLE+="- **Approve:** \`/meeting-ai approve\`\n"

          # Post comment
          echo -e "$TABLE" | gh issue comment "$ISSUE_NUMBER" --body-file -

      - name: Execute approved actions
        if: steps.check.outputs.command == 'approve'
        env:
          GH_TOKEN: ${{ github.token }}
          SESSION_KEY: ${{ steps.load_state.outputs.session_key }}
          STATE_JSON: ${{ steps.load_state.outputs.state }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          STATE_FILE=".github/meeting-ai-state.json"

          # Get actions from state
          actions=$(echo "$STATE_JSON" | jq -r '.actions // []')

          if [ "$actions" = "[]" ] || [ -z "$actions" ]; then
            gh issue comment "$ISSUE_NUMBER" --body "‚ùå No pending actions found. Use \`/meeting-ai paste <transcript>\` first."
            exit 0
          fi

          # Track results
          RESULTS_FILE=$(mktemp)
          echo "## ‚úÖ Meeting AI Actions Executed" > "$RESULTS_FILE"
          echo "" >> "$RESULTS_FILE"

          # Process each action
          echo "$actions" | jq -c '.[]' | while read -r action; do
            id=$(echo "$action" | jq -r '.id')
            type=$(echo "$action" | jq -r '.type')
            target=$(echo "$action" | jq -r '.target' | tr -d '#')

            case "$type" in
              close_issue)
                if gh issue close "$target" --comment "‚úÖ Closed via Meeting AI"; then
                  echo "- ‚úÖ Closed issue #$target" >> "$RESULTS_FILE"
                fi
                ;;
              reopen_issue)
                if gh issue reopen "$target" --comment "üîÑ Reopened via Meeting AI"; then
                  echo "- üîÑ Reopened issue #$target" >> "$RESULTS_FILE"
                fi
                ;;
              add_comment)
                comment=$(echo "$action" | jq -r '.details.comment // "Meeting update"')
                if gh issue comment "$target" --body "üìÖ **Meeting Update:**\n\n$comment"; then
                  echo "- üí¨ Commented on #$target" >> "$RESULTS_FILE"
                fi
                ;;
              update_labels)
                labels=$(echo "$action" | jq -r '.details.labels // [] | join(",")')
                if [ -n "$labels" ]; then
                  gh issue edit "$target" --add-label "$labels" && echo "- üè∑Ô∏è Labels updated on #$target" >> "$RESULTS_FILE"
                fi
                ;;
              set_milestone)
                milestone=$(echo "$action" | jq -r '.details.milestone')
                if [ -n "$milestone" ] && [ "$milestone" != "null" ]; then
                  gh issue edit "$target" --milestone "$milestone" && echo "- üìä Milestone set on #$target" >> "$RESULTS_FILE"
                fi
                ;;
              create_issue)
                title=$(echo "$action" | jq -r '.details.new_title // .title')
                body=$(echo "$action" | jq -r '.details.new_body // .reasoning')
                new_url=$(gh issue create --title "$title" --body "$body" 2>/dev/null)
                if [ -n "$new_url" ]; then
                  echo "- ‚ú® Created: $new_url" >> "$RESULTS_FILE"
                fi
                ;;
              assign_user)
                assignees=$(echo "$action" | jq -r '.details.assignees // [] | join(",")')
                if [ -n "$assignees" ]; then
                  gh issue edit "$target" --add-assignee "$assignees" && echo "- üë§ Assigned #$target to $assignees" >> "$RESULTS_FILE"
                fi
                ;;
              request_review)
                reviewers=$(echo "$action" | jq -r '.details.reviewers // [] | join(",")')
                if [ -n "$reviewers" ]; then
                  gh pr edit "$target" --add-reviewer "$reviewers" && echo "- üëÄ Review requested on PR #$target" >> "$RESULTS_FILE"
                fi
                ;;
              merge_pr)
                if gh pr merge "$target" --merge --body "Merged via Meeting AI"; then
                  echo "- üîÄ Merged PR #$target" >> "$RESULTS_FILE"
                fi
                ;;
              close_pr)
                if gh pr close "$target" --comment "Closed via Meeting AI"; then
                  echo "- ‚úÖ Closed PR #$target" >> "$RESULTS_FILE"
                fi
                ;;
            esac
          done

          # Clear session state
          jq --arg key "$SESSION_KEY" 'del(.sessions[$key])' "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"

          # Post results
          gh issue comment "$ISSUE_NUMBER" --body-file "$RESULTS_FILE"
          rm -f "$RESULTS_FILE"

      - name: Commit state changes
        if: always() && steps.check.outputs.command != ''
        run: |
          STATE_FILE=".github/meeting-ai-state.json"
          if [ -f "$STATE_FILE" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add "$STATE_FILE"
            if ! git diff --staged --quiet; then
              git commit -m "chore: update meeting-ai state [skip ci]"
              git push || echo "::warning::Failed to push state changes"
            fi
          fi
